<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>POPMAP</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css"/>

<style>
html, body { height:100%; margin:0; font-family:"Segoe UI", sans-serif; background:#ddd; }
#header-container { display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background:#2c3e50; color:white; }
#header-buttons button { padding:6px 12px; border:none; border-radius:4px; background:#2980b9; color:white; cursor:pointer; }
#header-buttons button:hover { background:#3498db; }
#controls { padding:10px 20px; display:flex; gap:10px; flex-wrap:wrap; }
#controls input { padding:6px 10px; border-radius:4px; border:1px solid #ccc; width:180px; background-color:#f4f4f4; color:#333; outline:none; }
#controls input:focus { border-color:#2980b9; box-shadow:0 0 2px #2980b9; }
#controls button { padding:6px 14px; border-radius:4px; border:none; background:#2980b9; color:white; cursor:pointer; }
#controls button:hover { background:#3498db; }
#map { width:100%; height:calc(100% - 110px); }
</style>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
</head>

<body>

<div id="header-container">
    <div>POPMAP</div>
    <div id="header-buttons">
        <button onclick="location.href='/login'">Menu</button>
    </div>
</div>

<div id="controls">
<input id="start" placeholder="Start lat,lon e.g. 35.189427,33.050308">
<input id="goal" placeholder="Goal lat,lon e.g. 35.216094,33.012543">
<button onclick="plotPath()">Show Path</button>
</div>

<div id="map"></div>

<script>
var drawnItems = new L.FeatureGroup();
var pathLayer;
var drawings = [];

fetch('/tile_bounds').then(r => r.json()).then(data => {
    if(data.error){ alert(data.error); return; }

    var bounds = data.bounds;      // [[south, west], [north, east]]
    var center = data.center;      // exact center from Flask
    var minZoom = data.minZoom;
    var maxZoom = data.maxZoom;

    // Initialize map at zoom 11, centered exactly
    var map = L.map('map', {
        center: center,
        zoom: 12,
        minZoom: minZoom,
        maxZoom: maxZoom
    });

    // Tiles below zoom 11 (free panning)
    L.tileLayer('static/tiles/{z}/{x}/{y}.png', {
        minZoom: minZoom,
        maxZoom: 10,
        noWrap: true
    }).addTo(map);

    // Tiles zoom 11+ (restricted)
    var tiles11plus = L.tileLayer('static/tiles/{z}/{x}/{y}.png', {
        minZoom: 11,
        maxZoom: maxZoom,
        noWrap: true
    }).addTo(map);

    // Restrict panning only for zoom >= 11
    function updateBounds() {
        if(map.getZoom() >= 11){
            map.setMaxBounds(bounds);
            map.options.maxBoundsViscosity = 1.0;
        } else {
            map.setMaxBounds(null);
        }
    }
    updateBounds();
    map.on('zoomend', updateBounds);

    // Draw controls
    map.addLayer(drawnItems);
    var drawControl = new L.Control.Draw({
        edit: { featureGroup: drawnItems },
        draw: { polygon:true, polyline:true, rectangle:true, circle:true, circlemarker:true, marker:true }
    });
    map.addControl(drawControl);

    // Load persisted drawings
    fetch('/static/drawings.json').then(r => r.json()).then(data => {
        drawings = data || [];
        drawings.forEach(f => {
            let l = featureToLayer(f);
            if(l) drawnItems.addLayer(l);
        });
    });

    // Drawing events
    map.on(L.Draw.Event.CREATED, e => {
        drawnItems.addLayer(e.layer);
        drawings.push(layerToFeature(e.layer));
        saveDrawings();
    });
    map.on(L.Draw.Event.EDITED, e => {
        e.layers.eachLayer(layer => {
            let idx = drawings.findIndex(f => f.properties._id === layer._leaflet_id);
            if(idx >= 0) drawings[idx] = layerToFeature(layer);
        });
        saveDrawings();
    });
    map.on(L.Draw.Event.DELETED, e => {
        e.layers.eachLayer(layer => { drawings = drawings.filter(f => f.properties._id !== layer._leaflet_id); });
        saveDrawings();
    });

    // Pathfinding
    window.plotPath = function() {
        let s = document.getElementById('start').value.split(',');
        let g = document.getElementById('goal').value.split(',');
        if(s.length !== 2 || g.length !== 2){ alert("Invalid input"); return; }
        let start_lat = parseFloat(s[0]), start_lon = parseFloat(s[1]);
        let goal_lat = parseFloat(g[0]), goal_lon = parseFloat(g[1]);
        if(isNaN(start_lat) || isNaN(start_lon) || isNaN(goal_lat) || isNaN(goal_lon)){ alert("Coords must be numbers"); return; }
        fetch(`/compute_path?start_lat=${start_lat}&start_lon=${start_lon}&goal_lat=${goal_lat}&goal_lon=${goal_lon}`)
        .then(res => res.json())
        .then(path => {
            if(path.error){ alert(path.error); return; }
            if(pathLayer) drawnItems.removeLayer(pathLayer);
            pathLayer = L.polyline(path.map(p => [p[0], p[1]]), { color:'red', weight:3 }).addTo(drawnItems);
            L.marker([path[0][0], path[0][1]]).addTo(map).bindPopup("Start");
            L.marker([path[path.length-1][0], path[path.length-1][1]]).addTo(map).bindPopup("Goal");
            map.fitBounds(pathLayer.getBounds());
        });
    }
});

// Helpers
function featureToLayer(f) {
    var layer = null;
    if(f.type === "Feature") {
        var g = f.geometry;
        if(g.type==="Polygon") layer = L.polygon(g.coordinates[0].map(c=>[c[1],c[0]]));
        else if(g.type==="LineString") layer = L.polyline(g.coordinates.map(c=>[c[1],c[0]]));
        else if(g.type==="Point"){
            if(f.properties && f.properties.radius) layer=L.circle([g.coordinates[1],g.coordinates[0]],{radius:f.properties.radius});
            else if(f.properties && f.properties.isCircleMarker) layer=L.circleMarker([g.coordinates[1],g.coordinates[0]]);
            else layer=L.marker([g.coordinates[1],g.coordinates[0]]);
        }
    }
    if(layer) layer._leaflet_id = f.properties._id || layer._leaflet_id;
    return layer;
}
function layerToFeature(layer){
    var feature={type:"Feature", properties:{_id:layer._leaflet_id}, geometry:{}};
    if(layer instanceof L.Marker) feature.geometry={type:"Point", coordinates:[layer.getLatLng().lng, layer.getLatLng().lat]};
    else if(layer instanceof L.Circle){ feature.geometry={type:"Point", coordinates:[layer.getLatLng().lng, layer.getLatLng().lat]}; feature.properties.radius = layer.getRadius(); }
    else if(layer instanceof L.CircleMarker){ feature.geometry={type:"Point", coordinates:[layer.getLatLng().lng, layer.getLatLng().lat]}; feature.properties.isCircleMarker = true; }
    else if(layer instanceof L.Polygon && !(layer instanceof L.Circle)) feature.geometry={type:"Polygon", coordinates:[layer.getLatLngs()[0].map(c=>[c.lng,c.lat])]};
    else if(layer instanceof L.Polyline) feature.geometry={type:"LineString", coordinates:layer.getLatLngs().map(c=>[c.lng,c.lat])};
    return feature;
}
function saveDrawings() {
    fetch('/save_drawings', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(drawings) });
}
</script>

</body>
</html>
