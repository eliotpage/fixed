<!DOCTYPE html>
<html>
<head>
    <title>Leaflet Map with Persistent Drawings</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css"/>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
</head>
<body>

<h2>Tile Map with Draw & Pathfinding</h2>

<div>
    Start (lat,lon): <input id="start" placeholder="e.g. 35.189427,33.050308">
    Goal (lat,lon): <input id="goal" placeholder="e.g. 35.216094,33.012543">
    <button onclick="plotPath()">Show Path</button>
</div>

<div id="map" style="width:100%; height:80vh;"></div>

<script>
    // 1️⃣ Initialize map
    var bounds = [[{{ bounds.south }}, {{ bounds.west }}], [{{ bounds.north }}, {{ bounds.east }}]];
    var map = L.map('map').fitBounds(bounds);

    L.tileLayer('static/tiles/{z}/{x}/{y}.png', {
        minZoom: {{ min_zoom }},
        maxZoom: {{ max_zoom }},
        noWrap: true,
        bounds: bounds
    }).addTo(map);

    var drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    var drawControl = new L.Control.Draw({
        edit: { featureGroup: drawnItems },
        draw: { polygon:true, polyline:true, rectangle:true, circle:true, circlemarker:true, marker:true }
    });
    map.addControl(drawControl);

    // 2️⃣ Client-side drawings array
    var drawings = [];

    // 3️⃣ Load drawings.json from server once
    fetch('/static/drawings.json')
        .then(res => res.json())
        .then(data => {
            drawings = data || [];
            drawings.forEach(f => {
                let layer = featureToLayer(f);
                if(layer) drawnItems.addLayer(layer);
            });
        });

    function featureToLayer(f) {
        var layer = null;
        if(f.type==="Feature"){
            var g = f.geometry;
            if(g.type==="Polygon") layer = L.polygon(g.coordinates[0].map(c=>[c[1],c[0]]));
            else if(g.type==="LineString") layer = L.polyline(g.coordinates.map(c=>[c[1],c[0]]));
            else if(g.type==="Point"){
                if(f.properties && f.properties.radius) layer = L.circle([g.coordinates[1], g.coordinates[0]], {radius: f.properties.radius});
                else if(f.properties && f.properties.isCircleMarker) layer = L.circleMarker([g.coordinates[1], g.coordinates[0]]);
                else layer = L.marker([g.coordinates[1], g.coordinates[0]]);
            }
        }
        if(layer) layer._leaflet_id = f.properties._id || layer._leaflet_id;
        return layer;
    }

    function layerToFeature(layer){
        var feature = {type:"Feature", properties:{_id: layer._leaflet_id}, geometry:{}};
        if(layer instanceof L.Marker) feature.geometry = {type:"Point", coordinates:[layer.getLatLng().lng, layer.getLatLng().lat]};
        else if(layer instanceof L.Circle){
            feature.geometry = {type:"Point", coordinates:[layer.getLatLng().lng, layer.getLatLng().lat]};
            feature.properties.radius = layer.getRadius();
        }
        else if(layer instanceof L.CircleMarker){
            feature.geometry = {type:"Point", coordinates:[layer.getLatLng().lng, layer.getLatLng().lat]};
            feature.properties.isCircleMarker = true;
        }
        else if(layer instanceof L.Polygon && !(layer instanceof L.Circle)){
            feature.geometry = {type:"Polygon", coordinates:[layer.getLatLngs()[0].map(c=>[c.lng,c.lat])] };
        }
        else if(layer instanceof L.Polyline){
            feature.geometry = {type:"LineString", coordinates:layer.getLatLngs().map(c=>[c.lng,c.lat])};
        }
        return feature;
    }

    function saveDrawings(){
        fetch('/save_drawings', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify(drawings)
        });
    }

    map.on(L.Draw.Event.CREATED, function(e){
        drawnItems.addLayer(e.layer);
        drawings.push(layerToFeature(e.layer));
        saveDrawings();
    });

    map.on(L.Draw.Event.EDITED, function(e){
        e.layers.eachLayer(layer=>{
            let idx = drawings.findIndex(f => f.properties._id === layer._leaflet_id);
            if(idx>=0) drawings[idx] = layerToFeature(layer);
        });
        saveDrawings();
    });

    map.on(L.Draw.Event.DELETED, function(e){
        e.layers.eachLayer(layer=>{
            drawings = drawings.filter(f => f.properties._id !== layer._leaflet_id);
        });
        saveDrawings();
    });
</script>


</body>
</html>
