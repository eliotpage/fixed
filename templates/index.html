<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>POPMAP</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css"/>
<style>
html,body{height:100%;margin:0;font-family:"Segoe UI",sans-serif;background:#f4f4f4;}
#header-container{display:flex;justify-content:space-between;align-items:center;padding:10px 20px;background:#2c3e50;color:white;}
#header-buttons button{padding:6px 12px;border:none;border-radius:4px;background:#2980b9;color:white;cursor:pointer;}
#header-buttons button:hover{background:#3498db;}
#controls {
    display: flex;
    justify-content: center;   /* center horizontally */
    gap: 10px;
    flex-wrap: wrap;
    padding: 10px 20px;
    background-color: #f4f4f4; /* match missing tiles */
    border-bottom: 1px solid #111;
}

#controls input {
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid #ccc;
    width: 180px;
    font-size: 14px;           /* match login inputs */
    background-color: #f4f4f4; /* match missing tile background */
}

#controls button {
    padding: 6px 14px;
    border-radius: 4px;
    border: none;
    background: #2980b9;
    color: white;
    cursor: pointer;
}

#controls button:hover {
    background: #3498db;
}

#map {
    width: 100%;
    height: calc(100% - 110px); /* leave space for header + controls */
}

</style>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
</head>
<body>

<div id="header-container">
    <div>POPMAP</div>
    <div id="header-buttons">
        <button onclick="location.href='/logout'">Logout</button>
    </div>
</div>

<!-- Separate banner for pathfinding controls -->
<div id="controls">
    <input id="start" placeholder="Start lat,lon e.g. 35.189427,33.050308">
    <input id="goal" placeholder="Goal lat,lon e.g. 35.216094,33.012543">
    <button onclick="plotPath()">Show Path</button>
</div>

<div id="map"></div>

<script>

var drawnItems = new L.FeatureGroup();
var pathLayer;
var startMarker = null;
var goalMarker = null;
var drawings = [];

// ================= LOAD MAP =================

fetch('/tile_bounds')
.then(r => r.json())
.then(data => {

    if (data.error) {
        alert(data.error);
        return;
    }

    var bounds = data.bounds;
    var center = data.center;
    var minZoom = data.minZoom;
    var maxZoom = data.maxZoom;

    // Create map
    var map = L.map('map', {
        center: center,
        zoom: 11,
        minZoom: minZoom,
        maxZoom: maxZoom
    });

    // Tile layers
    L.tileLayer('static/tiles/{z}/{x}/{y}.png', {
        minZoom: minZoom,
        maxZoom: 10,
        noWrap: true
    }).addTo(map);

    L.tileLayer('static/tiles/{z}/{x}/{y}.png', {
        minZoom: 11,
        maxZoom: maxZoom,
        noWrap: true
    }).addTo(map);


    // Restrict panning at zoom >= 11
    function updateBounds() {
        if (map.getZoom() >= 11) {
            map.setMaxBounds(bounds);
            map.options.maxBoundsViscosity = 1.0;
        } else {
            map.setMaxBounds(null);
        }
    }

    updateBounds();
    map.on('zoomend', updateBounds);


    // ================= DRAW TOOLS =================

    map.addLayer(drawnItems);

    var drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems
        },
        draw: {
            polygon: true,
            polyline: true,
            rectangle: true,
            circle: true,
            circlemarker: true,
            marker: true
        }
    });

    map.addControl(drawControl);


    // ================= LOAD DRAWINGS =================

    fetch('/static/drawings.json')
    .then(r => r.json())
    .then(data => {

        drawings = data || [];

        drawings.forEach(f => {

            // Skip deleted
            if (f.properties && f.properties.deleted) return;

            let layer = featureToLayer(f);

            if (layer) {
                drawnItems.addLayer(layer);
                bindPopupToLayer(layer);
            }
        });

    });


    // ================= DRAW EVENTS =================

    // Created
    map.on(L.Draw.Event.CREATED, e => {

        drawnItems.addLayer(e.layer);

        let feature = layerToFeature(e.layer);

        // Ensure not deleted
        feature.properties.deleted = false;

        drawings.push(feature);

        bindPopupToLayer(e.layer);

        saveDrawings();
    });


    // Edited
    map.on(L.Draw.Event.EDITED, e => {

        e.layers.eachLayer(layer => {

            let idx = drawings.findIndex(
                f => f.properties._id === layer._leaflet_id
            );

            if (idx >= 0) {
                drawings[idx] = layerToFeature(layer);
                drawings[idx].properties.deleted = false;
            }

        });

        saveDrawings();
    });


    // Deleted (soft delete)
    map.on(L.Draw.Event.DELETED, e => {

        e.layers.eachLayer(layer => {

            let feature = drawings.find(
                f => f.properties._id === layer._leaflet_id
            );

            if (feature) {
                feature.properties.deleted = true;
            }

        });

        saveDrawings();
    });


    // ================= PATHFINDING =================

    window.plotPath = function () {

        let s = document.getElementById('start').value.split(',');
        let g = document.getElementById('goal').value.split(',');

        if (s.length !== 2 || g.length !== 2) {
            alert("Invalid input");
            return;
        }

        let start_lat = parseFloat(s[0]);
        let start_lon = parseFloat(s[1]);
        let goal_lat = parseFloat(g[0]);
        let goal_lon = parseFloat(g[1]);

        if (
            isNaN(start_lat) ||
            isNaN(start_lon) ||
            isNaN(goal_lat) ||
            isNaN(goal_lon)
        ) {
            alert("Coords must be numbers");
            return;
        }

        fetch(`/compute_path?start_lat=${start_lat}&start_lon=${start_lon}&goal_lat=${goal_lat}&goal_lon=${goal_lon}`)
        .then(res => res.json())
        .then(path => {

            if (path.error) {
                alert(path.error);
                return;
            }

            // Remove old path + markers
            if (pathLayer) drawnItems.removeLayer(pathLayer);
            if (startMarker) drawnItems.removeLayer(startMarker);
            if (goalMarker) drawnItems.removeLayer(goalMarker);


            // Draw path
            pathLayer = L.polyline(
                path.map(p => [p[0], p[1]]),
                { color: 'red', weight: 3 }
            ).addTo(drawnItems);


            // Start marker
            startMarker = L.marker([path[0][0], path[0][1]])
                .addTo(drawnItems)
                .bindPopup(formatCoords(path[0][0], path[0][1]));


            // Goal marker
            let last = path[path.length - 1];

            goalMarker = L.marker([last[0], last[1]])
                .addTo(drawnItems)
                .bindPopup(formatCoords(last[0], last[1]));


            map.fitBounds(pathLayer.getBounds());

        });
    };

});


// ================= HELPERS =================


// Convert saved feature → leaflet layer
function featureToLayer(f) {

    var layer = null;

    if (f.type === "Feature") {

        var g = f.geometry;

        if (g.type === "Polygon") {
            layer = L.polygon(
                g.coordinates[0].map(c => [c[1], c[0]])
            );
        }

        else if (g.type === "LineString") {
            layer = L.polyline(
                g.coordinates.map(c => [c[1], c[0]])
            );
        }

        else if (g.type === "Point") {

            if (f.properties && f.properties.radius) {
                layer = L.circle(
                    [g.coordinates[1], g.coordinates[0]],
                    { radius: f.properties.radius }
                );
            }

            else if (f.properties && f.properties.isCircleMarker) {
                layer = L.circleMarker(
                    [g.coordinates[1], g.coordinates[0]]
                );
            }

            else {
                layer = L.marker(
                    [g.coordinates[1], g.coordinates[0]]
                );
            }
        }
    }

    if (layer) {
        layer._leaflet_id = f.properties._id || layer._leaflet_id;
    }

    return layer;
}


// Convert leaflet layer → feature
function layerToFeature(layer) {

    var feature = {
        type: "Feature",
        properties: {
            _id: layer._leaflet_id,
            deleted: false
        },
        geometry: {}
    };

    if (layer instanceof L.Marker) {

        feature.geometry = {
            type: "Point",
            coordinates: [
                layer.getLatLng().lng,
                layer.getLatLng().lat
            ]
        };
    }

    else if (layer instanceof L.Circle) {

        feature.geometry = {
            type: "Point",
            coordinates: [
                layer.getLatLng().lng,
                layer.getLatLng().lat
            ]
        };

        feature.properties.radius = layer.getRadius();
    }

    else if (layer instanceof L.CircleMarker) {

        feature.geometry = {
            type: "Point",
            coordinates: [
                layer.getLatLng().lng,
                layer.getLatLng().lat
            ]
        };

        feature.properties.isCircleMarker = true;
    }

    else if (layer instanceof L.Polygon && !(layer instanceof L.Circle)) {

        feature.geometry = {
            type: "Polygon",
            coordinates: [
                layer.getLatLngs()[0].map(c => [c.lng, c.lat])
            ]
        };
    }

    else if (layer instanceof L.Polyline) {

        feature.geometry = {
            type: "LineString",
            coordinates: layer.getLatLngs().map(c => [c.lng, c.lat])
        };
    }

    return feature;
}


// Show coords on click
function bindPopupToLayer(layer) {

    if (
        layer instanceof L.Marker ||
        layer instanceof L.Circle ||
        layer instanceof L.CircleMarker
    ) {

        let ll = layer.getLatLng();

        layer.bindPopup(
            formatCoords(ll.lat, ll.lng)
        );
    }
}


// Format coordinate popup
function formatCoords(lat, lon) {

    return `Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}`;
}


// Save to server
function saveDrawings() {

    fetch('/save_drawings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(drawings)
    });
}

</script>

</body>
</html>
